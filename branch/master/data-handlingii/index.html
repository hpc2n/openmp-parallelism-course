<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>More on Private Data &mdash; OpenMP parallelism in scientific computing  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
      <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
      <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
      <link rel="stylesheet" type="text/css" href="../_static/sphinx_lesson.css" />
      <link rel="stylesheet" type="text/css" href="../_static/term_role_formatting.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/clipboard.min.js"></script>
        <script src="../_static/copybutton.js"></script>
        <script src="../_static/minipres.js"></script>
        <script>let toggleHintShow = 'Click to show';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="../_static/togglebutton.js"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex/" />
    <link rel="search" title="Search" href="../search/" />
    <link rel="next" title="More on Worksharing" href="../worksharingii/" />
    <link rel="prev" title="Worksharing and Scheduling" href="../worksharing/" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../" class="icon icon-home">
            OpenMP parallelism in scientific computing
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Day 1</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../hpc2n-intro/">Introduction to HPC2N</a></li>
<li class="toctree-l1"><a class="reference internal" href="../setup/">Introduction to Kebnekaise</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling-analysis/">Profiling analysis with VTune and Advisor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling-analysis/#summary">Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../first-steps/">First Steps in OpenMP</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Day 2</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../data-handling/">Data for Parallel Regions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../worksharing/">Worksharing and Scheduling</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Day 3</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">More on Private Data</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#private-and-shared-data-review">Private and Shared Data: Review</a></li>
<li class="toctree-l2"><a class="reference internal" href="#clause-firstprivate">Clause: firstprivate</a></li>
<li class="toctree-l2"><a class="reference internal" href="#clause-lastprivate">Clause: lastprivate</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reduction-variables">Reduction Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="#user-defined-reductions">User-Defined Reductions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dealing-with-global-storage">Dealing with Global Storage</a></li>
<li class="toctree-l2"><a class="reference internal" href="#directive-threadprivate-in-c">Directive: threadprivate in C</a></li>
<li class="toctree-l2"><a class="reference internal" href="#directive-threadprivate-in-fortran">Directive: threadprivate in Fortran</a></li>
<li class="toctree-l2"><a class="reference internal" href="#clause-copyin">Clause: copyin</a></li>
<li class="toctree-l2"><a class="reference internal" href="#more-on-threadprivate">More on threadprivate</a></li>
<li class="toctree-l2"><a class="reference internal" href="#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../worksharingii/">More on Worksharing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Day 4</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tasks/">The Task Directive</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Miscellanous</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../quick-reference/">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guide/">Instructor’s guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../">OpenMP parallelism in scientific computing</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">More on Private Data</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/hpc2n/OpenMP-parallelism-course/blob/master/docs/data-handlingii.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="more-on-private-data">
<h1>More on Private Data<a class="headerlink" href="#more-on-private-data" title="Permalink to this heading"></a></h1>
<div class="admonition-objectives objectives admonition" id="objectives-0">
<p class="admonition-title">Objectives</p>
<p>This guide covers special versions of private data:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">firstprivate</span></code> - initialization of private variables</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lastprivate</span></code> - capturing values from last iteration</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reduction</span></code> - parallel reductions (sums, products, etc.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">threadprivate</span></code> - privatizing global storage</p></li>
<li><p>User-defined reductions (OpenMP 4.0+)</p></li>
</ul>
</div>
<section id="private-and-shared-data-review">
<h2>Private and Shared Data: Review<a class="headerlink" href="#private-and-shared-data-review" title="Permalink to this heading"></a></h2>
<p>In a parallel region, data can be either shared or private.</p>
<p><strong>Shared Data</strong></p>
<ul class="simple">
<li><p>Value unchanged on entry to parallel region</p></li>
<li><p>Survives after end of parallel region</p></li>
</ul>
<p><strong>Private Data</strong></p>
<ul class="simple">
<li><p>Each thread has its own private copy</p></li>
<li><p>Normally uninitialized at beginning of parallel region</p></li>
<li><p>Contents typically lost when parallel region finishes</p></li>
<li><p><strong>However:</strong> Connection to values before/after is often needed</p></li>
</ul>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/sm_3.png"><img alt="../_images/sm_3.png" src="../_images/sm_3.png" style="width: 242.39999999999998px; height: 164.1px;" /></a>
</figure>
<hr class="docutils" />
<p><em>Memory Layout</em></p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Main Memory: [Shared data]

Thread 0: [Private T0]
Thread 1: [Private T1]
Thread 2: [Private T2]
Thread 3: [Private T3]
</pre></div>
</div>
</section>
<section id="clause-firstprivate">
<h2>Clause: firstprivate<a class="headerlink" href="#clause-firstprivate" title="Permalink to this heading"></a></h2>
<p><em>Problem</em></p>
<p>Private variables are not initialized by default.</p>
<p><em>Solution: firstprivate Clause</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">firstprivate</span></code> clause:</p>
<ul class="simple">
<li><p>Declares variable(s) as private</p></li>
<li><p>Initializes each private copy with the value prior to the construct</p></li>
</ul>
<p><em>Fortran Example</em></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="kt">integer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lsum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span>

<span class="c">!$omp parallel &amp;</span>
<span class="c">!$omp firstprivate(lsum)</span>
<span class="w">    </span><span class="n">lsum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lsum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">()</span>
<span class="w">    </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">lsum</span>
<span class="c">!$omp end parallel</span>
</pre></div>
</div>
<p><em>C Example</em></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">lsum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>

<span class="cp">#pragma omp parallel \</span>
<span class="cp">    firstprivate(lsum)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">lsum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">();</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">lsum</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>Expected Output</em></p>
<p>With 4 threads:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Thread 0: 10
Thread 1: 11
Thread 2: 12
Thread 3: 13
</pre></div>
</div>
<p><em>Example: Vector Norm with private</em></p>
<p><em>Fortran Version</em></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span>

<span class="c">!$omp parallel default(none) &amp;</span>
<span class="c">!$omp shared(vect, norm) private(i, lNorm)</span>
<span class="w">    </span><span class="n">lNorm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span>

<span class="w">    </span><span class="c">!$omp do</span>
<span class="w">    </span><span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">vleng</span>
<span class="w">        </span><span class="n">lNorm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lNorm</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vect</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="w">    </span><span class="k">enddo</span>

<span class="w">    </span><span class="c">!$omp atomic update</span>
<span class="w">    </span><span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">norm</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">lNorm</span>
<span class="c">!$omp end parallel</span>

<span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">sqrt</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
</pre></div>
</div>
<p><em>C Version</em></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>

<span class="cp">#pragma omp parallel default(none) \</span>
<span class="cp">    shared(vect, norm) private(i, lNorm)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">lNorm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>

<span class="w">    </span><span class="cp">#pragma omp for</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">vleng</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">lNorm</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">vect</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vect</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="w">    </span><span class="cp">#pragma omp atomic update</span>
<span class="w">    </span><span class="n">norm</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">lNorm</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm</span><span class="p">);</span>
</pre></div>
</div>
<p>Mathematical notation: <span class="math notranslate nohighlight">\(\sqrt{\sum_i v(i) \cdot v(i)}\)</span></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">lNorm</span></code> must be explicitly initialized to 0.0 inside the parallel region.</p>
</div>
<p><em>Example: Vector Norm with firstprivate</em></p>
<p><em>Fortran Version</em></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span>
<span class="n">lNorm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span>

<span class="c">!$omp parallel default(none) &amp;</span>
<span class="c">!$omp shared(vect, norm) private(i) firstprivate(lNorm)</span>
<span class="w">    </span><span class="c">!$omp do</span>
<span class="w">    </span><span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">vleng</span>
<span class="w">        </span><span class="n">lNorm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lNorm</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vect</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="w">    </span><span class="k">enddo</span>

<span class="w">    </span><span class="c">!$omp atomic update</span>
<span class="w">    </span><span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">norm</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">lNorm</span>
<span class="c">!$omp end parallel</span>

<span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">sqrt</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
</pre></div>
</div>
<p><em>C Version</em></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="n">lNorm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>

<span class="cp">#pragma omp parallel default(none) \</span>
<span class="cp">    shared(vect, norm) private(i) firstprivate(lNorm)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cp">#pragma omp for</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">vleng</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">lNorm</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">vect</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vect</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="w">    </span><span class="cp">#pragma omp atomic update</span>
<span class="w">    </span><span class="n">norm</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">lNorm</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm</span><span class="p">);</span>
</pre></div>
</div>
<p>Mathematical notation: <span class="math notranslate nohighlight">\(\sqrt{\sum_i v(i) \cdot v(i)}\)</span></p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>With <code class="docutils literal notranslate"><span class="pre">firstprivate</span></code>, <code class="docutils literal notranslate"><span class="pre">lNorm</span></code> is automatically initialized to 0.0 from the master thread’s value.</p>
</div>
</section>
<section id="clause-lastprivate">
<h2>Clause: lastprivate<a class="headerlink" href="#clause-lastprivate" title="Permalink to this heading"></a></h2>
<p><em>Purpose</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">lastprivate</span></code> clause:</p>
<ul class="simple">
<li><p>Used with loop and sections constructs</p></li>
<li><p>Variable is private during execution</p></li>
<li><p>At the end: assigns value from last iteration or section</p></li>
<li><p>Undefined if not set in last iteration/section</p></li>
</ul>
<p><em>Combined Usage</em></p>
<p>Variables can be both <code class="docutils literal notranslate"><span class="pre">firstprivate</span></code> <strong>and</strong> <code class="docutils literal notranslate"><span class="pre">lastprivate</span></code>.</p>
<p><em>Fortran Example</em></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="kt">integer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">a</span>

<span class="c">!$omp parallel do &amp;</span>
<span class="c">!$omp lastprivate(a)</span>
<span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="k">call </span><span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="k">enddo</span>

<span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;a=&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span>
<span class="c">! This prints: a=101</span>
</pre></div>
</div>
<p><em>C Example</em></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>

<span class="cp">#pragma omp parallel for \</span>
<span class="cp">    lastprivate(a)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;a=%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="c1">// This prints: a=100</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value from the sequentially last iteration is assigned back to the original variable.</p>
</div>
</section>
<section id="reduction-variables">
<h2>Reduction Variables<a class="headerlink" href="#reduction-variables" title="Permalink to this heading"></a></h2>
<p>Reductions of private variables are frequently needed:</p>
<ul class="simple">
<li><p>Averages of array values</p></li>
<li><p>Scalar products</p></li>
<li><p>Sum, product, minimum, maximum operations</p></li>
</ul>
<p><em>Previous Approach</em></p>
<p>We’ve done this before (e.g., vector norm example) using <code class="docutils literal notranslate"><span class="pre">atomic</span></code> to protect the update.</p>
<p><em>Better Approach: Reduction Clause</em></p>
<p>For a reduction, we specify:</p>
<ul class="simple">
<li><p><strong>Operation:</strong> e.g., addition, multiplication, OR, AND, etc.</p></li>
<li><p><strong>One or more variables</strong></p></li>
<li><p>A construct can have more than one reduction</p></li>
</ul>
<p><em>Behavior of Reduction</em></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="n">reduction</span><span class="p">(</span><span class="n">operator</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">variable_list</span><span class="p">)</span>
</pre></div>
</div>
<p><em>How It Works</em></p>
<p><strong>Variables specified in reduction:</strong></p>
<ol class="arabic simple">
<li><p>Each thread gets a private copy</p></li>
<li><p>Private copies are initialized with default values matching the operator</p></li>
<li><p>At the end of the construct (e.g., parallel region):</p>
<ul class="simple">
<li><p>Value prior to construct is combined with private copies</p></li>
<li><p>Using the specified operator for combining values</p></li>
<li><p>New combined value is available after the construct</p></li>
</ul>
</li>
</ol>
<p><em>Example: Memory Movements for Reduction (C)</em></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>

<span class="cp">#pragma omp parallel \</span>
<span class="cp">    reduction(+:b)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
<p><em>Memory Behavior</em></p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Main Memory: b = 5

Thread 0: b = 0 → b = 0
Thread 1: b = 0 → b = 1
Thread 2: b = 0 → b = 2
Thread 3: b = 0 → b = 3

Final: 5 + 0 + 1 + 2 + 3 = 11
</pre></div>
</div>
<p>Output: <code class="docutils literal notranslate"><span class="pre">11</span></code></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Each thread’s private copy is initialized to 0 (identity for addition), then combined at the end.</p>
</div>
<p><em>Example: Memory Movements for Reduction (Fortran)</em></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="kt">integer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">b</span>

<span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span>

<span class="c">!$omp parallel &amp;</span>
<span class="c">!$omp reduction(+:b)</span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">()</span>
<span class="c">!$omp end parallel</span>

<span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>
</pre></div>
</div>
<p><em>Memory Behavior</em></p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Main Memory: b = 5

Thread 0: b = 0 → b = 0
Thread 1: b = 0 → b = 1
Thread 2: b = 0 → b = 2
Thread 3: b = 0 → b = 3

Final: 5 + 0 + 1 + 2 + 3 = 11
</pre></div>
</div>
<p>Output: <code class="docutils literal notranslate"><span class="pre">11</span></code></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Each thread’s private copy is initialized to 0 (identity for addition), then combined at the end.</p>
</div>
<p><em>Example: Vector Norm with atomic update</em></p>
<p><em>Fortran Version</em></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span>
<span class="n">lNorm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span>

<span class="c">!$omp parallel default(none) &amp;</span>
<span class="c">!$omp shared(vect, norm) private(i) firstprivate(lNorm)</span>
<span class="w">    </span><span class="c">!$omp do</span>
<span class="w">    </span><span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">vleng</span>
<span class="w">        </span><span class="n">lNorm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lNorm</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vect</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="w">  </span><span class="c">! private copy</span>
<span class="w">    </span><span class="k">enddo</span>

<span class="w">    </span><span class="c">!$omp atomic update</span>
<span class="w">    </span><span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">norm</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">lNorm</span>
<span class="c">!$omp end parallel  ! combine copies</span>

<span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">sqrt</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span><span class="w">  </span><span class="c">! master copy</span>
</pre></div>
</div>
<p><em>C Version</em></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="n">lNorm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>

<span class="cp">#pragma omp parallel default(none) \</span>
<span class="cp">    shared(vect, norm) private(i) firstprivate(lNorm)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cp">#pragma omp for</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">vleng</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">lNorm</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">vect</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vect</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="w">    </span><span class="cp">#pragma omp atomic update</span>
<span class="w">    </span><span class="n">norm</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">lNorm</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm</span><span class="p">);</span>
</pre></div>
</div>
<p>Mathematical notation: <span class="math notranslate nohighlight">\(\sqrt{\sum_i v(i) \cdot v(i)}\)</span></p>
<p><em>Example: Vector Norm with reduction</em></p>
<p><em>Fortran Version</em></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="w">  </span><span class="c">! master copy</span>
<span class="c">! lNorm gone</span>

<span class="c">!$omp parallel default(none) &amp;</span>
<span class="c">!$omp shared(vect) reduction(+:norm) private(i)</span>
<span class="w">    </span><span class="c">!$omp do  ! private copy = 0</span>
<span class="w">    </span><span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">vleng</span>
<span class="w">        </span><span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">norm</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vect</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="w">  </span><span class="c">! private copy</span>
<span class="w">    </span><span class="k">enddo</span>
<span class="c">!$omp end parallel  ! combine copies</span>

<span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">sqrt</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span><span class="w">  </span><span class="c">! master copy</span>
</pre></div>
</div>
<p><em>C Version</em></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w">  </span><span class="c1">// master copy</span>
<span class="c1">// lNorm gone!</span>

<span class="cp">#pragma omp parallel default(none) \</span>
<span class="cp">    shared(vect) reduction(+:norm) private(i)</span>
<span class="p">{</span><span class="w">  </span><span class="c1">// private copy: 0</span>
<span class="w">    </span><span class="cp">#pragma omp for</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">vleng</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">norm</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">vect</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vect</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">  </span><span class="c1">// private copy</span>
<span class="p">}</span><span class="w">  </span><span class="c1">// combine copies</span>

<span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm</span><span class="p">);</span><span class="w">  </span><span class="c1">// master copy</span>
</pre></div>
</div>
<p>Mathematical notation: <span class="math notranslate nohighlight">\(\sqrt{\sum_i v(i) \cdot v(i)}\)</span></p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>No need for <code class="docutils literal notranslate"><span class="pre">lNorm</span></code> variable or <code class="docutils literal notranslate"><span class="pre">atomic</span></code> directive. The reduction clause handles everything automatically.</p>
</div>
<p><em>Example: Vector Norm with reduction (Simplified)</em></p>
<p><em>Fortran Version</em></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="w">  </span><span class="c">! master copy</span>

<span class="c">!$omp parallel do default(none) &amp;</span>
<span class="c">!$omp shared(vect) reduction(+:norm)</span>
<span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">vleng</span>
<span class="w">    </span><span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">norm</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vect</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="w">  </span><span class="c">! private copy</span>
<span class="k">enddo</span>
<span class="c">!$omp end parallel do</span>

<span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">sqrt</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span><span class="w">  </span><span class="c">! master copy</span>
</pre></div>
</div>
<p><em>C Version</em></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w">  </span><span class="c1">// master copy</span>

<span class="cp">#pragma omp parallel for default(none) \</span>
<span class="cp">    shared(vect) reduction(+:norm)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">vleng</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="n">norm</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">vect</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vect</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">  </span><span class="c1">// private copy</span>

<span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm</span><span class="p">);</span><span class="w">  </span><span class="c1">// master copy</span>
</pre></div>
</div>
<p>Mathematical notation: <span class="math notranslate nohighlight">\(\sqrt{\sum_i v(i) \cdot v(i)}\)</span></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Using <code class="docutils literal notranslate"><span class="pre">parallel</span> <span class="pre">do</span></code>/<code class="docutils literal notranslate"><span class="pre">parallel</span> <span class="pre">for</span></code> makes the code even more concise.</p>
</div>
<p><em>Supported Operators: Fortran (OpenMP 3.0)</em></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28.6%" />
<col style="width: 21.4%" />
<col style="width: 50.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Symbol</p></th>
<th class="head"><p>Initial Value of Local Copy</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>add</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">+</span></code></p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>multiply</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">*</span></code></p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>subtract</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>logical AND</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.and.</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.true.</span></code></p></td>
</tr>
<tr class="row-even"><td><p>logical OR</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.or.</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.false.</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>EQUIVALENCE</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.eqv.</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.true.</span></code></p></td>
</tr>
<tr class="row-even"><td><p>NON-EQUIV.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.neqv.</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.false.</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>maximum</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">max</span></code></p></td>
<td><p>smallest representable number</p></td>
</tr>
<tr class="row-even"><td><p>minimum</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">min</span></code></p></td>
<td><p>largest representable number</p></td>
</tr>
<tr class="row-odd"><td><p>bitwise AND</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">iand</span></code></p></td>
<td><p>all bits on</p></td>
</tr>
<tr class="row-even"><td><p>bitwise OR</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ior</span></code></p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>bitwise XOR</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ieor</span></code></p></td>
<td><p>0</p></td>
</tr>
</tbody>
</table>
<p><em>Supported Operators: C (OpenMP 3.0)</em></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28.6%" />
<col style="width: 21.4%" />
<col style="width: 50.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Symbol</p></th>
<th class="head"><p>Initial Value of Local Copy</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>add</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">+</span></code></p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>multiply</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">*</span></code></p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>subtract</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>bitwise AND</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&amp;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">~0</span></code></p></td>
</tr>
<tr class="row-even"><td><p>bitwise OR</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">|</span></code></p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>bitwise XOR</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">^</span></code></p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>logical AND</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code></p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>logical OR</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">||</span></code></p></td>
<td><p>0</p></td>
</tr>
</tbody>
</table>
<p><em>Restrictions on Reduction</em></p>
<p>Important Limitations</p>
<p><strong>C/C++:</strong></p>
<ul class="simple">
<li><p>Arrays are <strong>unsupported</strong> as reduction variables</p></li>
<li><p>No pointer or reference types</p></li>
</ul>
<p><strong>Fortran:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> arrays must be allocated at the beginning of construct</p></li>
<li><p>Must not be deallocated during construct</p></li>
<li><p>No Fortran pointers or assumed-size arrays</p></li>
</ul>
<p><em>Order of Execution</em></p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>No order of threads is specified!</p>
<ul class="simple">
<li><p>Repeated runs are typically <strong>not bit-identical</strong></p></li>
<li><p>This is common in parallel computing</p></li>
<li><p>This is technically a race condition, which is typically tolerated</p></li>
</ul>
</div>
<p><em>OpenMP 4.0 Enhancement</em></p>
<p>OpenMP 4.0 allows you to declare your own custom reductions.</p>
</section>
<section id="user-defined-reductions">
<h2>User-Defined Reductions<a class="headerlink" href="#user-defined-reductions" title="Permalink to this heading"></a></h2>
<p>Allows definition of custom reduction operations.</p>
<p><em>Use Cases</em></p>
<p>Particularly useful with derived data types:</p>
<ul class="simple">
<li><p><strong>C/C++:</strong> <code class="docutils literal notranslate"><span class="pre">struct</span></code></p></li>
<li><p><strong>Fortran:</strong> <code class="docutils literal notranslate"><span class="pre">type</span></code></p></li>
</ul>
<p><em>Requirements</em></p>
<p>You need to provide:</p>
<ol class="arabic simple">
<li><p><strong>Combiner:</strong> Combines thread-private results to final result</p></li>
<li><p><strong>Initializer:</strong> Initializes private contributions at outset</p></li>
</ol>
<p><em>Case Study: Maximum Value and Its Position</em></p>
<p>Given a large array:</p>
<ul class="simple">
<li><p>Determine the maximum value</p></li>
<li><p>Find the location (index) of the maximum in the array</p></li>
</ul>
<p>Parallelization Strategy:</p>
<ol class="arabic simple">
<li><p>Assign a portion of array to each thread</p></li>
<li><p>Each thread determines maximum and position in its part</p></li>
<li><p>Use user-defined reduction to determine final result</p></li>
</ol>
<p><em>User-Defined Reduction in Fortran</em></p>
<p>Step 1: Define the Data Type</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">type</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">mx_s</span>
<span class="w">    </span><span class="kt">real</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="k">value</span>
<span class="k">    </span><span class="kt">integer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="nb">index</span>
<span class="k">end type</span>
</pre></div>
</div>
<p>Step 2: Declare the Reduction</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!$omp declare reduction(maxloc: mx_s: &amp;</span>
<span class="c">!$omp mx_combine(omp_out, omp_in)) &amp;</span>
<span class="c">!$omp initializer(mx_init(omp_priv, omp_orig))</span>
</pre></div>
</div>
<ul class="simple">
<li><p>The operation can be triggered by the name <code class="docutils literal notranslate"><span class="pre">maxloc</span></code></p></li>
<li><p>Utilizes subroutine <code class="docutils literal notranslate"><span class="pre">mx_combine</span></code> and <code class="docutils literal notranslate"><span class="pre">mx_init</span></code></p></li>
<li><p>Acts on objects of type <code class="docutils literal notranslate"><span class="pre">mx_s</span></code></p></li>
</ul>
<p><em>The Initializer in Fortran</em></p>
<p>Can be a subroutine or assignment statement (here: subroutine).</p>
<p>Special Variables:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">omp_priv</span></code>: reference to variable to be initialized</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">omp_orig</span></code>: reference to original variable prior to construct</p></li>
</ul>
<p><em>Example Implementation</em></p>
<p>Initialize from value prior to construct:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">mx_init</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span><span class="w"> </span><span class="n">orig</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="p">(</span><span class="n">mx_s</span><span class="p">),</span><span class="w"> </span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">priv</span>
<span class="w">    </span><span class="k">type</span><span class="p">(</span><span class="n">mx_s</span><span class="p">),</span><span class="w"> </span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">orig</span>

<span class="w">    </span><span class="n">priv</span><span class="p">%</span><span class="k">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">orig</span><span class="p">%</span><span class="k">value</span>
<span class="k">    </span><span class="n">priv</span><span class="p">%</span><span class="nb">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">orig</span><span class="p">%</span><span class="nb">index</span>
<span class="k">end subroutine </span><span class="n">mx_init</span>
</pre></div>
</div>
<p><em>The Combiner in Fortran</em></p>
<p>Can be a subroutine or assignment statement (here: subroutine).</p>
<p>Special Variables:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">omp_in</span></code>: reference to contribution from thread</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">omp_out</span></code>: reference to combined result</p></li>
</ul>
<p><em>Example Implementation</em></p>
<p>Replace if contribution is larger:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">mx_combine</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="p">(</span><span class="n">mx_s</span><span class="p">),</span><span class="w"> </span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">out</span>
<span class="w">    </span><span class="k">type</span><span class="p">(</span><span class="n">mx_s</span><span class="p">),</span><span class="w"> </span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">in</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">out</span><span class="p">%</span><span class="k">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">in</span><span class="p">%</span><span class="k">value</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">        </span><span class="n">out</span><span class="p">%</span><span class="k">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">%</span><span class="k">value</span>
<span class="k">        </span><span class="n">out</span><span class="p">%</span><span class="nb">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">%</span><span class="nb">index</span>
<span class="nb">    </span><span class="k">endif</span>
<span class="k">end subroutine </span><span class="n">mx_combine</span>
</pre></div>
</div>
<p><em>Using User-Defined Reduction in Fortran</em></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="n">mx</span><span class="p">%</span><span class="k">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">mx</span><span class="p">%</span><span class="nb">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>

<span class="c">!$omp parallel do reduction(maxloc: mx)</span>
<span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="nb">count</span>
<span class="nb">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mx</span><span class="p">%</span><span class="k">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">val</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="k">then</span>
<span class="k">        </span><span class="n">mx</span><span class="p">%</span><span class="k">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="n">mx</span><span class="p">%</span><span class="nb">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span>
<span class="w">    </span><span class="k">endif</span>
<span class="k">enddo</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Easily readable code</p></li>
<li><p>Similar to what one would do in serial programming</p></li>
<li><p>Abstracts away the parallel complexity</p></li>
</ul>
<p><em>User-Defined Reduction in C</em></p>
<p>Step 1: Define the Data Type</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">mx_s</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Step 2: Declare the Reduction</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma omp declare reduction(maxloc: \</span>
<span class="cp">    struct mx_s: mx_combine(&amp;omp_out, &amp;omp_in)) \</span>
<span class="cp">    initializer(mx_init(&amp;omp_priv, &amp;omp_orig))</span>
</pre></div>
</div>
<ul class="simple">
<li><p>The operation can be triggered by the name <code class="docutils literal notranslate"><span class="pre">maxloc</span></code></p></li>
<li><p>Utilizes functions <code class="docutils literal notranslate"><span class="pre">mx_combine</span></code> and <code class="docutils literal notranslate"><span class="pre">mx_init</span></code></p></li>
<li><p>Acts on objects of type <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mx_s</span></code></p></li>
</ul>
<p><em>The Initializer in C</em></p>
<p>An expression (here: implemented with a function).</p>
<p>Special Variables:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">omp_priv</span></code>: reference to variable to be initialized</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">omp_orig</span></code>: reference to original variable prior to construct</p></li>
</ul>
<p><em>Example Implementation</em></p>
<p>Initialize from value prior to construct:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">mx_init</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">mx_s</span><span class="w"> </span><span class="o">*</span><span class="n">priv</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">mx_s</span><span class="w"> </span><span class="o">*</span><span class="n">orig</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">orig</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">orig</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>The Combiner in C</em></p>
<p>An expression (here: implemented with a function).</p>
<p>Special Variables:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">omp_in</span></code>: reference to contribution from thread</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">omp_out</span></code>: reference to combined result</p></li>
</ul>
<p><em>Example Implementation</em></p>
<p>Replace if contribution is larger:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">mx_combine</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">mx_s</span><span class="w"> </span><span class="o">*</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">mx_s</span><span class="w"> </span><span class="o">*</span><span class="n">in</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
<span class="w">        </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>Using User-Defined Reduction in C</em></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">mx</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">mx</span><span class="o">-&gt;</span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="cp">#pragma omp parallel for reduction(maxloc: mx)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mx</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">mx</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="n">mx</span><span class="p">.</span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Easily readable code</p></li>
<li><p>Similar to what one would do in serial programming</p></li>
<li><p>Abstracts away the parallel complexity</p></li>
</ul>
<p><em>Declaring a Reduction Operation: Syntax Summary</em></p>
<p>C Syntax</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma omp declare reduction (reduction-identifier : \</span>
<span class="cp">    typename-list : combiner) [initializer-clause] new-line</span>
</pre></div>
</div>
<p>Fortran Syntax</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!$omp declare reduction(reduction-identifier : &amp;</span>
<span class="c">!$omp type-list : combiner) [initializer-clause]</span>
</pre></div>
</div>
<p><em>Components</em></p>
<ul class="simple">
<li><p><strong>reduction-identifier:</strong> Name for your reduction</p></li>
<li><p><strong>typename-list/type-list:</strong> Data types the reduction applies to</p></li>
<li><p><strong>combiner:</strong> Function/subroutine to combine values</p></li>
<li><p><strong>initializer-clause:</strong> Optional initialization specification</p></li>
</ul>
</section>
<section id="dealing-with-global-storage">
<h2>Dealing with Global Storage<a class="headerlink" href="#dealing-with-global-storage" title="Permalink to this heading"></a></h2>
<p>By default, global storage is shared among all threads.</p>
<p><em>Examples of Global Storage</em></p>
<p><strong>C/C++:</strong></p>
<ul class="simple">
<li><p>File scope variables</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">static</span></code> variables</p></li>
</ul>
<p><strong>Fortran:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">COMMON</span></code> blocks</p></li>
<li><p>Module data</p></li>
<li><p>Variables with <code class="docutils literal notranslate"><span class="pre">save</span></code> attribute</p></li>
</ul>
<p>This default behavior is not always what is needed.</p>
</section>
<section id="directive-threadprivate-in-c">
<h2>Directive: threadprivate in C<a class="headerlink" href="#directive-threadprivate-in-c" title="Permalink to this heading"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">threadprivate</span></code> directive makes global storage private to each thread.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">g_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#pragma omp threadprivate(g_var)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">g_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>

<span class="w">    </span><span class="cp">#pragma omp parallel</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">g_var</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Each thread gets a private copy</p></li>
<li><p>Outside parallel region: modifications affect master’s copy</p></li>
</ul>
<p><em>Example Output</em></p>
<p>With 4 threads:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Thread 0 (master): 4
Thread 1: 1
Thread 2: 1
Thread 3: 1
</pre></div>
</div>
</section>
<section id="directive-threadprivate-in-fortran">
<h2>Directive: threadprivate in Fortran<a class="headerlink" href="#directive-threadprivate-in-fortran" title="Permalink to this heading"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">threadprivate</span></code> directive makes global storage private to each thread.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">module </span><span class="n">gmod</span>
<span class="w">    </span><span class="kt">integer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">g_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="c">!$omp threadprivate(g_var)</span>
<span class="k">end module </span><span class="n">gmod</span>

<span class="k">program </span><span class="n">example</span>
<span class="w">    </span><span class="k">use </span><span class="n">gmod</span>

<span class="w">    </span><span class="n">g_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span>

<span class="w">    </span><span class="c">!$omp parallel</span>
<span class="w">    </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">g_var</span>
<span class="w">    </span><span class="c">!$omp end parallel</span>
<span class="k">end program </span><span class="n">example</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Each thread gets a private copy</p></li>
<li><p>Outside parallel region: modifications affect master’s copy</p></li>
</ul>
<p><em>Example Output</em></p>
<p>With 4 threads:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Thread 0 (master): 4
Thread 1: 1
Thread 2: 1
Thread 3: 1
</pre></div>
</div>
</section>
<section id="clause-copyin">
<h2>Clause: copyin<a class="headerlink" href="#clause-copyin" title="Permalink to this heading"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">copyin</span></code> clause initializes threadprivate data from the master thread.</p>
<p>C Example</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">g_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#pragma omp threadprivate(g_var)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">g_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>

<span class="w">    </span><span class="cp">#pragma omp parallel \</span>
<span class="cp">        copyin(g_var)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">g_var</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Fortran Example</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">module </span><span class="n">gmod</span>
<span class="w">    </span><span class="kt">integer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">g_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="c">!$omp threadprivate(g_var)</span>
<span class="k">end module </span><span class="n">gmod</span>

<span class="k">program </span><span class="n">example</span>
<span class="w">    </span><span class="k">use </span><span class="n">gmod</span>

<span class="w">    </span><span class="n">g_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span>

<span class="w">    </span><span class="c">!$omp parallel copyin(g_var)</span>
<span class="w">    </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">g_var</span>
<span class="w">    </span><span class="c">!$omp end parallel</span>
<span class="k">end program </span><span class="n">example</span>
</pre></div>
</div>
<p><em>Output</em></p>
<p>With 4 threads, <strong>all</strong> threads print: <code class="docutils literal notranslate"><span class="pre">4</span></code></p>
</section>
<section id="more-on-threadprivate">
<h2>More on threadprivate<a class="headerlink" href="#more-on-threadprivate" title="Permalink to this heading"></a></h2>
<p><em>Data Persistence</em></p>
<p><code class="docutils literal notranslate"><span class="pre">threadprivate</span></code> data remains unchanged between parallel regions if:</p>
<ol class="arabic simple">
<li><p>Neither region is nested inside another parallel region</p></li>
<li><p>Both regions have the same thread count</p></li>
<li><p>Internal variable <code class="docutils literal notranslate"><span class="pre">dyn-var</span></code> is false in both regions</p>
<ul class="simple">
<li><p>Use function <code class="docutils literal notranslate"><span class="pre">omp_set_dynamic</span></code> to control this</p></li>
</ul>
</li>
</ol>
<p><em>Fortran COMMON Blocks</em></p>
<p>In Fortran, you can make a <code class="docutils literal notranslate"><span class="pre">COMMON</span></code> block threadprivate:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="kt">integer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span>
<span class="k">COMMON</span><span class="w"> </span><span class="o">/</span><span class="n">abccom</span><span class="o">/</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span>
<span class="c">!$OMP threadprivate(/abccom/)</span>
</pre></div>
</div>
<div class="admonition-exercise exercise important admonition" id="exercise-0">
<p class="admonition-title">Exercise</p>
<p>In a previous exercise, we parallelized a <strong>for</strong> loop which had 20 iterations by evenly divinding the
number of interations among the available threads. An variable was used to store the number of iterations
in the loop and an <em>atomic</em> operation protected the data from race conditions. Rewrite this code but
now use the <em>reduction</em> operation.</p>
</div>
<div class="admonition-solution solution important dropdown admonition" id="solution-0">
<p class="admonition-title">Solution</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// On cluster Kebnekaise</span>
<span class="linenos"> 2</span><span class="c1">// ml foss</span>
<span class="linenos"> 3</span><span class="c1">// export OMP_NUM_THREADS=1</span>
<span class="linenos"> 4</span><span class="c1">// gcc -O3 -march=native -fopenmp -o test.x 6b-forworksharing-openmp.c -lm</span>
<span class="linenos"> 5</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="linenos"> 6</span><span class="cp">#ifdef _OPENMP</span>
<span class="linenos"> 7</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span>
<span class="linenos"> 8</span><span class="cp">#endif</span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="linenos">11</span><span class="p">{</span>
<span class="linenos">12</span>
<span class="linenos">13</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">var1</span><span class="p">;</span>
<span class="linenos">14</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="c1">// number of iterations</span>
<span class="linenos">15</span><span class="n">var1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">16</span>
<span class="linenos">17</span><span class="cp">#pragma omp parallel</span>
<span class="linenos">18</span><span class="w">    </span><span class="p">{</span>
<span class="linenos">19</span><span class="cp">#ifdef _OPENMP</span>
<span class="linenos">20</span><span class="w">    </span><span class="c1">// The purpose of this code is to add 1 to var1 20 times</span>
<span class="linenos">21</span><span class="cp">#pragma omp for reduction(+:var1)</span>
<span class="linenos">22</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="linenos">23</span><span class="w">        </span><span class="n">var1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="linenos">24</span>
<span class="linenos">25</span><span class="cp">#else</span>
<span class="linenos">26</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Serial code!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="linenos">27</span><span class="cp">#endif</span>
<span class="linenos">28</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">29</span>
<span class="linenos">30</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;var1 =  %i </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">var1</span><span class="p">);</span>
<span class="linenos">31</span>
<span class="linenos">32</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">33</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="admonition-exercise exercise important admonition" id="exercise-1">
<p class="admonition-title">Exercise</p>
<p>In the following code, monitor the values of the variables at the different stages of the runtime.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// On cluster Kebnekaise</span>
<span class="linenos"> 2</span><span class="c1">// ml foss</span>
<span class="linenos"> 3</span><span class="c1">// export OMP_NUM_THREADS=1</span>
<span class="linenos"> 4</span><span class="c1">// gcc -O3 -march=native -fopenmp -o test.x 5b-datascope-openmp.c -lm</span>
<span class="linenos"> 5</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="linenos"> 6</span><span class="cp">#ifdef _OPENMP</span>
<span class="linenos"> 7</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span>
<span class="linenos"> 8</span><span class="cp">#endif</span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="linenos">11</span><span class="p">{</span>
<span class="linenos">12</span>
<span class="linenos">13</span><span class="kt">int</span><span class="w"> </span><span class="n">var1</span><span class="p">,</span><span class="w"> </span><span class="n">var2</span><span class="p">,</span><span class="w"> </span><span class="n">var3</span><span class="p">;</span><span class="w">   </span><span class="c1">// Three variables</span>
<span class="linenos">14</span><span class="n">var1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="linenos">15</span><span class="n">var2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="linenos">16</span><span class="n">var3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="linenos">17</span>
<span class="linenos">18</span><span class="cp">#pragma omp parallel firstprivate(var1,var2) shared(var3)</span>
<span class="linenos">19</span><span class="w">    </span><span class="p">{</span>
<span class="linenos">20</span>
<span class="linenos">21</span><span class="cp">#ifdef _OPENMP</span>
<span class="linenos">22</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;var1 =  %i , var2 = %i , var3 = %i </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">var1</span><span class="p">,</span><span class="n">var2</span><span class="p">,</span><span class="n">var3</span><span class="p">);</span>
<span class="linenos">23</span><span class="w">    </span><span class="n">var1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="linenos">24</span><span class="w">    </span><span class="n">var2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span>
<span class="linenos">25</span><span class="w">    </span><span class="n">var3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span>
<span class="linenos">26</span><span class="cp">#else</span>
<span class="linenos">27</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Serial code!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="linenos">28</span><span class="cp">#endif</span>
<span class="linenos">29</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">30</span>
<span class="linenos">31</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;var1 =  %i , var2 = %i , var3 = %i </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">var1</span><span class="p">,</span><span class="n">var2</span><span class="p">,</span><span class="n">var3</span><span class="p">);</span>
<span class="linenos">32</span>
<span class="linenos">33</span>
<span class="linenos">34</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// variable to hold the value from the last iteration</span>
<span class="linenos">35</span>
<span class="linenos">36</span><span class="cp">#pragma omp parallel for lastprivate(x)</span>
<span class="linenos">37</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">38</span><span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="c1">// x is private to each thread, but will retain value from the last iteration</span>
<span class="linenos">39</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Thread %d: i = %d, x = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">(),</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="linenos">40</span><span class="p">}</span>
<span class="linenos">41</span>
<span class="linenos">42</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;After the loop, x = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// x has the value from the last iteration (n - 1)</span>
<span class="linenos">43</span>
<span class="linenos">44</span>
<span class="linenos">45</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">46</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="admonition-exercise exercise important admonition" id="exercise-2">
<p class="admonition-title">Exercise</p>
<p>In the following code, monitor the values of the variable <em>counter</em> at the different stages of the runtime.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// On cluster Kebnekaise</span>
<span class="linenos"> 2</span><span class="c1">// ml foss</span>
<span class="linenos"> 3</span><span class="c1">// export OMP_NUM_THREADS=1</span>
<span class="linenos"> 4</span><span class="c1">// gcc -O3 -march=native -fopenmp -o test.x 7-threadprivate-openmp.c -lm</span>
<span class="linenos"> 5</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="linenos"> 6</span><span class="cp">#ifdef _OPENMP</span>
<span class="linenos"> 7</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span>
<span class="linenos"> 8</span><span class="cp">#endif</span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="c1">// declare a global variable</span>
<span class="linenos">11</span><span class="kt">int</span><span class="w"> </span><span class="n">counter</span><span class="p">;</span>
<span class="linenos">12</span>
<span class="linenos">13</span><span class="c1">// this variable is private to each thread</span>
<span class="linenos">14</span><span class="cp">#pragma omp threadprivate(counter)</span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="linenos">17</span><span class="p">{</span>
<span class="linenos">18</span>
<span class="linenos">19</span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">20</span>
<span class="linenos">21</span><span class="cp">#pragma omp parallel</span>
<span class="linenos">22</span><span class="p">{</span>
<span class="linenos">23</span><span class="cp">#ifdef _OPENMP</span>
<span class="linenos">24</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">();</span>
<span class="linenos">25</span>
<span class="linenos">26</span><span class="w">    </span><span class="c1">// Each thread sets its private copy of &#39;counter&#39;</span>
<span class="linenos">27</span><span class="w">    </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread_id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="linenos">28</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Thread %d: counter = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">thread_id</span><span class="p">,</span><span class="w"> </span><span class="n">counter</span><span class="p">);</span>
<span class="linenos">29</span>
<span class="linenos">30</span><span class="w">    </span><span class="c1">// sync all threads</span>
<span class="linenos">31</span><span class="w">    </span><span class="cp">#pragma omp barrier</span>
<span class="linenos">32</span>
<span class="linenos">33</span><span class="w">    </span><span class="c1">// Modify the thread-private variable</span>
<span class="linenos">34</span><span class="w">    </span><span class="n">counter</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="linenos">35</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Thread %d after modification: counter = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">thread_id</span><span class="p">,</span><span class="w"> </span><span class="n">counter</span><span class="p">);</span>
<span class="linenos">36</span><span class="cp">#else</span>
<span class="linenos">37</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Serial code!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="linenos">38</span><span class="cp">#endif</span>
<span class="linenos">39</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">40</span>
<span class="linenos">41</span><span class="c1">// Outside the parallel region, the main thread&#39;s &#39;counter&#39; value is unaffected</span>
<span class="linenos">42</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;In main thread, counter = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">counter</span><span class="p">);</span>
<span class="linenos">43</span>
<span class="linenos">44</span><span class="cp">#pragma omp parallel</span>
<span class="linenos">45</span><span class="p">{</span>
<span class="linenos">46</span><span class="cp">#ifdef _OPENMP</span>
<span class="linenos">47</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">();</span>
<span class="linenos">48</span>
<span class="linenos">49</span><span class="w">    </span><span class="c1">// print the value of &#39;counter&#39; in another parallel region</span>
<span class="linenos">50</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Thread %d: counter = %d in the second parallel region</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">thread_id</span><span class="p">,</span><span class="w"> </span><span class="n">counter</span><span class="p">);</span>
<span class="linenos">51</span>
<span class="linenos">52</span><span class="cp">#else</span>
<span class="linenos">53</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Serial code!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="linenos">54</span><span class="cp">#endif</span>
<span class="linenos">55</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">56</span>
<span class="linenos">57</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">58</span><span class="p">}</span>
</pre></div>
</div>
</div>
</section>
<section id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this heading"></a></h2>
<p>This guide covered special private variables in OpenMP:</p>
<p><em>Special Private Variable Types</em></p>
<ul class="simple">
<li><p><strong>firstprivate:</strong> Initialization of private variables from master thread</p></li>
<li><p><strong>lastprivate:</strong> Set value of private variable to value of last loop iteration or last section at end of construct</p></li>
<li><p><strong>reduction:</strong> Calculating sums, products, etc. in parallel</p></li>
<li><p><strong>threadprivate:</strong> Privatize global storage</p></li>
</ul>
<p><em>User-Defined Reductions</em></p>
<ul class="simple">
<li><p>Available in OpenMP 4.0+</p></li>
<li><p>Useful for complex data types</p></li>
<li><p>Requires combiner and initializer functions</p></li>
</ul>
<p><em>When to Use Standard Constructs</em></p>
<p>The above constructs handle standard situations. For special cases, use:</p>
<ul class="simple">
<li><p>Explicit initialization of private variables from shared variables</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">atomic</span></code>/<code class="docutils literal notranslate"><span class="pre">critical</span></code> for writes to shared variables</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../worksharing/" class="btn btn-neutral float-left" title="Worksharing and Scheduling" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../worksharingii/" class="btn btn-neutral float-right" title="More on Worksharing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, The contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>