<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The Task Directive &mdash; OpenMP parallelism in scientific computing  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
      <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
      <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
      <link rel="stylesheet" type="text/css" href="../_static/sphinx_lesson.css" />
      <link rel="stylesheet" type="text/css" href="../_static/term_role_formatting.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/clipboard.min.js"></script>
        <script src="../_static/copybutton.js"></script>
        <script src="../_static/minipres.js"></script>
        <script>let toggleHintShow = 'Click to show';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="../_static/togglebutton.js"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex/" />
    <link rel="search" title="Search" href="../search/" />
    <link rel="next" title="Quick Reference" href="../quick-reference/" />
    <link rel="prev" title="More on Worksharing" href="../worksharingii/" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../" class="icon icon-home">
            OpenMP parallelism in scientific computing
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Day 1</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../hpc2n-intro/">Introduction to HPC2N</a></li>
<li class="toctree-l1"><a class="reference internal" href="../setup/">Introduction to Kebnekaise</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling-analysis/">Profiling analysis with VTune and Advisor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling-analysis/#summary">Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../first-steps/">First Steps in OpenMP</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Day 2</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../data-handling/">Data for Parallel Regions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../worksharing/">Worksharing and Scheduling</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Day 3</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../data-handlingii/">More on Private Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../worksharingii/">More on Worksharing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Day 4</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">The Task Directive</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#regular-vs-irregular-structures">Regular vs. Irregular Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-task-construct">The Task Construct</a></li>
<li class="toctree-l2"><a class="reference internal" href="#allowed-data-sharing-attributes-for-tasks">Allowed Data Sharing Attributes for Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#data-sharing-without-a-default-clause">Data Sharing Without a default Clause</a></li>
<li class="toctree-l2"><a class="reference internal" href="#controlling-when-tasks-finish">Controlling When Tasks Finish</a></li>
<li class="toctree-l2"><a class="reference internal" href="#allowing-suspension-of-current-task">Allowing Suspension of Current Task</a></li>
<li class="toctree-l2"><a class="reference internal" href="#taskgroup-controlling-descendant-tasks-openmp-4-0">taskgroup: Controlling Descendant Tasks (OpenMP 4.0)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#controlling-task-creation">Controlling Task Creation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#final-tasks">Final Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mergeable-tasks">Mergeable Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#task-scheduling-points">Task Scheduling Points</a></li>
<li class="toctree-l2"><a class="reference internal" href="#basic-algorithm">Basic Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#task-dependencies-openmp-4-0">Task Dependencies (OpenMP 4.0)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#taskloop-construct-openmp-4-5">taskloop Construct (OpenMP 4.5)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#clauses-for-taskloop">Clauses for taskloop</a></li>
<li class="toctree-l2"><a class="reference internal" href="#controlling-number-of-tasks-created">Controlling Number of Tasks Created</a></li>
<li class="toctree-l2"><a class="reference internal" href="#summary">Summary</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Miscellanous</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../quick-reference/">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guide/">Instructor’s guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../">OpenMP parallelism in scientific computing</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">The Task Directive</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/hpc2n/OpenMP-parallelism-course/blob/master/docs/tasks.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="the-task-directive">
<h1>The Task Directive<a class="headerlink" href="#the-task-directive" title="Permalink to this heading"></a></h1>
<div class="admonition-objectives objectives admonition" id="objectives-0">
<p class="admonition-title">Objectives</p>
<ul class="simple">
<li><p>Learn the basic terminology.</p></li>
<li><p>Learn about the <code class="code docutils literal notranslate"><span class="pre">task</span></code> construct.</p></li>
<li><p>Learn more about data sharing rules.</p></li>
<li><p>Learn how to construct a task graph in a three-based manner.</p></li>
<li><p>Learn how to construct a task graph in a centralised manner.</p></li>
<li><p>Learn how to wait tasks to complete their execution.</p></li>
</ul>
</div>
<p>Beyond Regular Loops</p>
<section id="regular-vs-irregular-structures">
<h2>Regular vs. Irregular Structures<a class="headerlink" href="#regular-vs-irregular-structures" title="Permalink to this heading"></a></h2>
<p><strong>So far we’ve discussed regular structures:</strong></p>
<ul class="simple">
<li><p>Loops with known start and end</p></li>
<li><p>Fortran array constructs</p></li>
</ul>
<p><strong>Many problems have irregular structures:</strong></p>
<ul class="simple">
<li><p>Recursive algorithms</p></li>
<li><p>Linked lists</p></li>
<li><p>Loops with unknown end (e.g., <code class="docutils literal notranslate"><span class="pre">while</span></code> loops)</p></li>
<li><p>Divide and conquer algorithms</p></li>
<li><p>And more…</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Depending on the details, irregular structures might still be parallelizable using tasks.</p>
</div>
</section>
<section id="the-task-construct">
<h2>The Task Construct<a class="headerlink" href="#the-task-construct" title="Permalink to this heading"></a></h2>
<p>The task construct provides a flexible way to express parallelism for irregular problems.</p>
<p><em>Key Concept</em></p>
<p>Tasks allow you to create units of work that can be executed by any thread in the team, now or later.</p>
<p><em>The Task Directive in Fortran</em></p>
<p>Syntax</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!$omp task [clauses]</span>
<span class="w">    </span><span class="n">code</span><span class="w"> </span><span class="n">body</span>
<span class="c">!$omp end task</span>
</pre></div>
</div>
<p><em>What It Does</em></p>
<p>Creates an “explicit task” from:</p>
<ul class="simple">
<li><p>Code body</p></li>
<li><p>Data environment at that point</p></li>
<li><p>Place inside a parallel region</p></li>
</ul>
<p><em>Execution</em></p>
<p>The task may execute:</p>
<ul class="simple">
<li><p><strong>When:</strong> Now or later</p></li>
<li><p><strong>By whom:</strong> Encountering thread or other thread</p></li>
</ul>
<p>The thread that encounters the <code class="code docutils literal notranslate"><span class="pre">task</span></code> construct creates an explicit task from the structured block.
The encountering thread</p>
<blockquote>
<div><ul class="simple">
<li><p>may execute the task <strong>immediately</strong> or</p></li>
<li><p><strong>defer its execution</strong> to one of the other threads in the team.</p></li>
</ul>
</div></blockquote>
<p>A task is always <strong>bound to the innermost parallel region</strong>.
If a task construct is encountered outside a parallel region, then the structured block is executed immediately by the encountering thread.</p>
<p>The <code class="code docutils literal notranslate"><span class="pre">task</span></code> construct accepts a set of clauses:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="hll"><span class="k">if</span><span class="p">([</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="o">:</span><span class="p">]</span><span class="w"> </span><span class="n">scalar</span><span class="o">-</span><span class="n">expression</span><span class="p">)</span>
</span><span class="n">final</span><span class="p">(</span><span class="n">scalar</span><span class="o">-</span><span class="n">expression</span><span class="p">)</span>
<span class="n">untied</span>
<span class="hll"><span class="k">default</span><span class="p">(</span><span class="n">shared</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">none</span><span class="p">)</span>
</span><span class="n">mergeable</span>
<span class="hll"><span class="n">private</span><span class="p">(</span><span class="n">list</span><span class="p">)</span>
</span><span class="hll"><span class="n">firstprivate</span><span class="p">(</span><span class="n">list</span><span class="p">)</span>
</span><span class="hll"><span class="n">shared</span><span class="p">(</span><span class="n">list</span><span class="p">)</span>
</span><span class="n">in_reduction</span><span class="p">(</span><span class="n">reduction</span><span class="o">-</span><span class="n">identifier</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="p">)</span>
<span class="n">depend</span><span class="p">([</span><span class="n">depend</span><span class="o">-</span><span class="n">modifier</span><span class="p">,]</span><span class="w"> </span><span class="n">dependence</span><span class="o">-</span><span class="n">type</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">locator</span><span class="o">-</span><span class="n">list</span><span class="p">)</span>
<span class="n">priority</span><span class="p">(</span><span class="n">priority</span><span class="o">-</span><span class="n">value</span><span class="p">)</span>
<span class="n">allocate</span><span class="p">([</span><span class="n">allocator</span><span class="w"> </span><span class="o">:</span><span class="p">]</span><span class="w"> </span><span class="n">list</span><span class="p">)</span>
<span class="n">affinity</span><span class="p">([</span><span class="n">aff</span><span class="o">-</span><span class="n">modifier</span><span class="w"> </span><span class="o">:</span><span class="p">]</span><span class="w"> </span><span class="n">locator</span><span class="o">-</span><span class="n">list</span><span class="p">)</span>
<span class="n">detach</span><span class="p">(</span><span class="n">event</span><span class="o">-</span><span class="n">handle</span><span class="p">)</span>
</pre></div>
</div>
<p>We can already recognise some of the clauses.
For example, the <code class="code docutils literal notranslate"><span class="pre">if</span></code> clause can be used to enable/disable the creation of the corresponding task, and the <code class="code docutils literal notranslate"><span class="pre">default</span></code>, <code class="code docutils literal notranslate"><span class="pre">private</span></code>, <code class="code docutils literal notranslate"><span class="pre">firstprivate</span></code>, and <code class="code docutils literal notranslate"><span class="pre">shared</span></code> clauses are used to control the data sharing rules.
It should be noted that some of these clauses behave slightly differently when compared to the traditional OpenMP constructs.</p>
<p>Let us return to the earlier “Hello world” program:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="hll"><span class="linenos"> 4</span><span class="w">    </span><span class="cp">#pragma omp parallel</span>
</span><span class="linenos"> 5</span><span class="w">    </span><span class="p">{</span>
<span class="hll"><span class="linenos"> 6</span><span class="w">        </span><span class="cp">#pragma omp task</span>
</span><span class="linenos"> 7</span><span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello world!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="linenos"> 8</span><span class="w">    </span><span class="p">}</span>
<span class="linenos"> 9</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">10</span><span class="p">}</span>
</pre></div>
</div>
<p>Note that the <code class="code docutils literal notranslate"><span class="pre">task</span></code> pragma is <strong>inside a parallel construct</strong>.
Each thread in the team</p>
<blockquote>
<div><ul class="simple">
<li><p>encounters the task construct,</p></li>
<li><p>creates the corresponding task and</p></li>
<li><p>either executes the task immediately or defer its execution to one of the other threads in the team:</p></li>
</ul>
</div></blockquote>
<figure class="align-default">
<img alt="../_images/task.png" src="../_images/task.png" />
</figure>
<p>Therefore, the number of tasks, and lines printed, are the same as the number of threads in the team:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>gcc<span class="w"> </span>-o<span class="w"> </span>my_program<span class="w"> </span>my_program.c<span class="w"> </span>-Wall<span class="w"> </span>-fopenmp
$<span class="w"> </span>./my_program
<span class="hll">Hello<span class="w"> </span>world!
</span><span class="hll">Hello<span class="w"> </span>world!
</span><span class="hll">...
</span><span class="hll">Hello<span class="w"> </span>world!
</span></pre></div>
</div>
<p><em>The Task Directive in C</em></p>
<p>Syntax</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma omp task [clauses]</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">code</span><span class="w"> </span><span class="n">body</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>What It Does</em></p>
<p>Creates an “explicit task” from:</p>
<ul class="simple">
<li><p>Code body</p></li>
<li><p>Data environment at that point</p></li>
<li><p>Place inside a parallel region</p></li>
</ul>
<p><em>Execution</em></p>
<p>The task may execute:</p>
<ul class="simple">
<li><p><strong>When:</strong> Now or later</p></li>
<li><p><strong>By whom:</strong> Encountering thread or other thread</p></li>
</ul>
</section>
<section id="allowed-data-sharing-attributes-for-tasks">
<h2>Allowed Data Sharing Attributes for Tasks<a class="headerlink" href="#allowed-data-sharing-attributes-for-tasks" title="Permalink to this heading"></a></h2>
<p><em>Available Attributes</em></p>
<p><strong>private:</strong></p>
<ul class="simple">
<li><p>Data is private to the task</p></li>
</ul>
<p><strong>firstprivate:</strong></p>
<ul class="simple">
<li><p>Data is private to the task</p></li>
<li><p>Data initialized when task directive is encountered</p></li>
</ul>
<p><strong>shared:</strong></p>
<ul class="simple">
<li><p>Data is shared</p></li>
<li><p><strong>Only way to return a result from a task!</strong></p></li>
</ul>
<p><strong>default:</strong></p>
<ul class="simple">
<li><p><strong>Fortran:</strong> <code class="docutils literal notranslate"><span class="pre">shared</span> <span class="pre">|</span> <span class="pre">private</span> <span class="pre">|</span> <span class="pre">firstprivate</span> <span class="pre">|</span> <span class="pre">none</span></code></p></li>
<li><p><strong>C:</strong> <code class="docutils literal notranslate"><span class="pre">shared</span> <span class="pre">|</span> <span class="pre">none</span></code></p></li>
</ul>
</section>
<section id="data-sharing-without-a-default-clause">
<h2>Data Sharing Without a default Clause<a class="headerlink" href="#data-sharing-without-a-default-clause" title="Permalink to this heading"></a></h2>
<p>When no <code class="docutils literal notranslate"><span class="pre">default</span></code> is declared on a task directive:</p>
<p><em>Default Rules</em></p>
<p><strong>If variable is shared by all implicit tasks in the current team:</strong></p>
<p>Variable is: <code class="docutils literal notranslate"><span class="pre">shared</span></code></p>
<p><strong>Otherwise:</strong></p>
<p>Variable is: <code class="docutils literal notranslate"><span class="pre">firstprivate</span></code></p>
<p><em>Recommendation</em></p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">default(none)</span></code> to be explicit about data sharing!</p>
</div>
<p><em>Example: Task Execution Flow</em></p>
<p>Consider this code:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="n">code</span><span class="w"> </span><span class="k">block </span><span class="mi">1</span>
<span class="c">!$omp task</span>
<span class="w">    </span><span class="n">code</span><span class="w"> </span><span class="k">block </span><span class="mi">2</span>
<span class="c">!$omp end task</span>
<span class="n">code</span><span class="w"> </span><span class="k">block </span><span class="mi">3</span>
</pre></div>
</div>
<p><em>Thread Encountering This Code</em></p>
<ol class="arabic simple">
<li><p><strong>Executes</strong> “code block 1”</p></li>
<li><p><strong>Creates a task</strong> for “code block 2”</p></li>
<li><p><strong>May:</strong></p>
<ul class="simple">
<li><p>Execute the task for “code block 2”</p></li>
<li><p>Pick up another task</p></li>
<li><p>Continue with “code block 3”</p></li>
</ul>
</li>
<li><p><strong>At some point:</strong> Has to execute code block 3</p></li>
</ol>
<p><em>No Control Over</em></p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<ul class="simple">
<li><p>Who executes code block 2</p></li>
<li><p>When code block 2 is finished</p></li>
</ul>
</div>
</section>
<section id="controlling-when-tasks-finish">
<h2>Controlling When Tasks Finish<a class="headerlink" href="#controlling-when-tasks-finish" title="Permalink to this heading"></a></h2>
<p><em>taskwait Directive</em></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!$omp taskwait</span>
</pre></div>
</div>
<p><strong>Purpose:</strong></p>
<ul class="simple">
<li><p>Ensures child tasks have completed</p></li>
<li><p><strong>Does not</strong> consider grandchildren, etc.</p></li>
</ul>
<p><em>barrier Directive</em></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!$omp barrier</span>
</pre></div>
</div>
<p><strong>Purpose:</strong></p>
<ul class="simple">
<li><p>Ensures <strong>all tasks</strong> in the innermost parallel region have finished</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Instead of waiting, a thread can execute tasks generated elsewhere.</p>
</div>
</section>
<section id="allowing-suspension-of-current-task">
<h2>Allowing Suspension of Current Task<a class="headerlink" href="#allowing-suspension-of-current-task" title="Permalink to this heading"></a></h2>
<p><em>taskyield Construct</em></p>
<p>At a <code class="docutils literal notranslate"><span class="pre">taskyield</span></code> construct, the current task can be suspended to execute a different task.</p>
<p>Syntax</p>
<p><strong>Fortran:</strong></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!$omp taskyield</span>
</pre></div>
</div>
<p><strong>C:</strong></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma omp taskyield</span>
</pre></div>
</div>
<p><em>Use Case</em></p>
<p>Allows the runtime to schedule other tasks while waiting for resources or dependencies.</p>
</section>
<section id="taskgroup-controlling-descendant-tasks-openmp-4-0">
<h2>taskgroup: Controlling Descendant Tasks (OpenMP 4.0)<a class="headerlink" href="#taskgroup-controlling-descendant-tasks-openmp-4-0" title="Permalink to this heading"></a></h2>
<p>A <code class="docutils literal notranslate"><span class="pre">taskgroup</span></code> construct defines a region with an implied task scheduling point at the end.</p>
<p>Current task is suspended until <strong>all descendant tasks</strong> (including grandchildren, etc.) have completed.</p>
<p><em>Fortran Syntax</em></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!$omp taskgroup</span>
<span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>
<span class="w">    </span><span class="c">!$omp task ...</span>
<span class="w">        </span><span class="k">call </span><span class="n">processing</span><span class="p">(...)</span>
<span class="w">    </span><span class="c">!$omp end task</span>
<span class="k">end do</span>
<span class="c">!$omp end taskgroup  ! Waits for all tasks, including</span>
<span class="w">                      </span><span class="c">! tasks generated in processing</span>
</pre></div>
</div>
<p><em>C Syntax</em></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma omp taskgroup</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cp">#pragma omp task ...</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">processing</span><span class="p">(...);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span><span class="w">  </span><span class="c1">// Waits for all tasks, including</span>
<span class="w">   </span><span class="c1">// tasks generated in processing</span>
</pre></div>
</div>
</section>
<section id="controlling-task-creation">
<h2>Controlling Task Creation<a class="headerlink" href="#controlling-task-creation" title="Permalink to this heading"></a></h2>
<p><em>The Overhead Problem</em></p>
<p>Creating a task encounters significant overhead:</p>
<ul class="simple">
<li><p>Requires significant work inside the task to pay off</p></li>
<li><p>Too many small tasks can hurt performance</p></li>
</ul>
<p><em>Solution: if Clause</em></p>
<p>Use the <code class="docutils literal notranslate"><span class="pre">if</span></code> clause to control task creation:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!$OMP task if(level .lt. 10) ...</span>
<span class="w">    </span><span class="p">...</span>
<span class="c">!$OMP end task</span>
</pre></div>
</div>
<p>If the expression evaluates to <code class="docutils literal notranslate"><span class="pre">.false.</span></code>:</p>
<ul class="simple">
<li><p>Encountering thread executes code body directly (included task)</p></li>
<li><p>No task creation overhead</p></li>
</ul>
</section>
<section id="final-tasks">
<h2>Final Tasks<a class="headerlink" href="#final-tasks" title="Permalink to this heading"></a></h2>
<p>A task can carry a <code class="docutils literal notranslate"><span class="pre">final</span></code> clause to control task generation in descendants.</p>
<p><em>Syntax</em></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!$OMP task final(level .gt. 30) ...</span>
<span class="w">    </span><span class="p">...</span>
<span class="c">!$OMP end task</span>
</pre></div>
</div>
<p>If the expression evaluates to <code class="docutils literal notranslate"><span class="pre">.true.</span></code>:</p>
<ul class="simple">
<li><p>All encountered tasks within this task will be:</p>
<ul>
<li><p><strong>Included</strong> (executed immediately by encountering thread)</p></li>
<li><p><strong>Final</strong> (they also cannot generate new tasks)</p></li>
</ul>
</li>
</ul>
<p><em>Use Case</em></p>
<p>Prevents excessive task creation in deep recursion by serializing once a certain depth is reached.</p>
</section>
<section id="mergeable-tasks">
<h2>Mergeable Tasks<a class="headerlink" href="#mergeable-tasks" title="Permalink to this heading"></a></h2>
<p>A task can be declared as <code class="docutils literal notranslate"><span class="pre">mergeable</span></code> for optimization.</p>
<p><em>Syntax</em></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!$omp task mergeable ...</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma omp task mergeable ...</span>
</pre></div>
</div>
<p>For an undeferred or included task, the implementation may:</p>
<ul class="simple">
<li><p>Use the data environment of the generating task (including internal control variables)</p></li>
<li><p>Optimize by merging task execution</p></li>
</ul>
<p><em>Use Case</em></p>
<p>Often used with <code class="docutils literal notranslate"><span class="pre">final</span></code> clause for optimization at deep recursion levels.</p>
</section>
<section id="task-scheduling-points">
<h2>Task Scheduling Points<a class="headerlink" href="#task-scheduling-points" title="Permalink to this heading"></a></h2>
<p>Threads may switch to a different task at a <strong>task scheduling point</strong>.</p>
<p><em>Task Scheduling Points Are</em></p>
<ol class="arabic simple">
<li><p>Immediately after generation of an explicit task</p></li>
<li><p>After point of completion of a task</p></li>
<li><p>At <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> or <code class="docutils literal notranslate"><span class="pre">taskyield</span></code></p></li>
<li><p>At <code class="docutils literal notranslate"><span class="pre">barrier</span></code> (explicit or implicit)</p></li>
<li><p>At the end of <code class="docutils literal notranslate"><span class="pre">taskgroup</span></code></p></li>
</ol>
<p><strong>Untied Tasks (Advanced)</strong></p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Untied tasks (not covered in this course) may switch at any point.</p>
<ul class="simple">
<li><p>Be careful with <code class="docutils literal notranslate"><span class="pre">critical</span></code> regions and locks</p></li>
<li><p>Example: task may switch out of critical region → <strong>deadlock!</strong></p></li>
</ul>
</div>
<p><em>Case Study 1: Recursive Fibonacci</em></p>
<p>Fibonacci Numbers Mathematical series:</p>
<div class="math notranslate nohighlight">
\[\begin{split}F_0 &amp;= 0 \\
F_1 &amp;= 1 \\
F_n &amp;= F_{n-1} + F_{n-2}\end{split}\]</div>
<p>First numbers in series: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, …</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Recursive implementation: not efficient for computation, but good for demonstrating task parallelism!</p>
</div>
<p><em>Serial Fibonacci Implementation (Fortran)</em></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">recursive function </span><span class="n">recursive_fib</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="k">result</span><span class="p">(</span><span class="n">fibnum</span><span class="p">)</span>
<span class="w">    </span><span class="kt">integer</span><span class="p">,</span><span class="w"> </span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">in</span>
<span class="w">    </span><span class="kt">integer</span><span class="p">(</span><span class="n">lint</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">fibnum</span><span class="p">,</span><span class="w"> </span><span class="n">sub1</span><span class="p">,</span><span class="w"> </span><span class="n">sub2</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">in</span><span class="w"> </span><span class="p">.</span><span class="n">gt</span><span class="p">.</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">        </span><span class="n">sub1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recursive_fib</span><span class="p">(</span><span class="n">in</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="n">sub2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recursive_fib</span><span class="p">(</span><span class="n">in</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">        </span><span class="n">fibnum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sub1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sub2</span>
<span class="w">    </span><span class="k">else</span>
<span class="k">        </span><span class="n">fibnum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span>
<span class="w">    </span><span class="k">endif</span>
<span class="k">end function </span><span class="n">recursive_fib</span>
</pre></div>
</div>
<p><em>Recursion Tree</em></p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>             n
          /     \
       n-1       n-2
      /   \     /   \
   n-2   n-3  n-3  n-4
  / \    / \  / \  / \
...  ... ... ... ... ...
</pre></div>
</div>
<p><em>Parallel Version: Attempt 1 (Fortran)</em></p>
<p>Adding One Task</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">recursive function </span><span class="n">recursive_fib</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="k">result</span><span class="p">(</span><span class="n">fibnum</span><span class="p">)</span>
<span class="w">    </span><span class="kt">integer</span><span class="p">,</span><span class="w"> </span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">in</span>
<span class="w">    </span><span class="kt">integer</span><span class="p">(</span><span class="n">lint</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">fibnum</span><span class="p">,</span><span class="w"> </span><span class="n">sub1</span><span class="p">,</span><span class="w"> </span><span class="n">sub2</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">in</span><span class="w"> </span><span class="p">.</span><span class="n">gt</span><span class="p">.</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="w">        </span><span class="c">!$OMP task shared(sub1) firstprivate(in)</span>
<span class="w">            </span><span class="n">sub1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recursive_fib</span><span class="p">(</span><span class="n">in</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="c">!$OMP end task</span>
<span class="w">        </span><span class="n">sub2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recursive_fib</span><span class="p">(</span><span class="n">in</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">        </span><span class="n">fibnum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sub1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sub2</span>
<span class="w">    </span><span class="k">else</span>
<span class="k">        </span><span class="n">fibnum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span>
<span class="w">    </span><span class="k">endif</span>
<span class="k">end function </span><span class="n">recursive_fib</span>
</pre></div>
</div>
<p><em>Data Sharing</em></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sub1</span></code> is <code class="docutils literal notranslate"><span class="pre">shared</span></code> - declared inside function, must share to return result</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">in</span></code> is <code class="docutils literal notranslate"><span class="pre">firstprivate</span></code> - initialized at task creation</p></li>
</ul>
<p><em>Parallel Version: Attempt 2 (Fortran)</em></p>
<p>Adding Second Task</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">recursive function </span><span class="n">recursive_fib</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="k">result</span><span class="p">(</span><span class="n">fibnum</span><span class="p">)</span>
<span class="w">    </span><span class="kt">integer</span><span class="p">,</span><span class="w"> </span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">in</span>
<span class="w">    </span><span class="kt">integer</span><span class="p">(</span><span class="n">lint</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">fibnum</span><span class="p">,</span><span class="w"> </span><span class="n">sub1</span><span class="p">,</span><span class="w"> </span><span class="n">sub2</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">in</span><span class="w"> </span><span class="p">.</span><span class="n">gt</span><span class="p">.</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="w">        </span><span class="c">!$OMP task shared(sub1) firstprivate(in)</span>
<span class="w">            </span><span class="n">sub1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recursive_fib</span><span class="p">(</span><span class="n">in</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="c">!$OMP end task</span>
<span class="w">        </span><span class="c">!$OMP task shared(sub2) firstprivate(in)</span>
<span class="w">            </span><span class="n">sub2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recursive_fib</span><span class="p">(</span><span class="n">in</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">        </span><span class="c">!$OMP end task</span>
<span class="w">        </span><span class="n">fibnum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sub1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sub2</span>
<span class="w">    </span><span class="k">else</span>
<span class="k">        </span><span class="n">fibnum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span>
<span class="w">    </span><span class="k">endif</span>
<span class="k">end function </span><span class="n">recursive_fib</span>
</pre></div>
</div>
<div class="admonition danger">
<p class="admonition-title">Danger</p>
<p><strong>Problem:</strong> Need to have <code class="docutils literal notranslate"><span class="pre">sub1</span></code> and <code class="docutils literal notranslate"><span class="pre">sub2</span></code> ready before computing <code class="docutils literal notranslate"><span class="pre">fibnum</span></code>!</p>
</div>
<p><em>Parallel Version: Final Solution (Fortran)</em></p>
<p>Adding taskwait</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">recursive function </span><span class="n">recursive_fib</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="k">result</span><span class="p">(</span><span class="n">fibnum</span><span class="p">)</span>
<span class="w">    </span><span class="kt">integer</span><span class="p">,</span><span class="w"> </span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">in</span>
<span class="w">    </span><span class="kt">integer</span><span class="p">(</span><span class="n">lint</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">fibnum</span><span class="p">,</span><span class="w"> </span><span class="n">sub1</span><span class="p">,</span><span class="w"> </span><span class="n">sub2</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">in</span><span class="w"> </span><span class="p">.</span><span class="n">gt</span><span class="p">.</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="w">        </span><span class="c">!$OMP task shared(sub1) firstprivate(in)</span>
<span class="w">            </span><span class="n">sub1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recursive_fib</span><span class="p">(</span><span class="n">in</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="c">!$OMP end task</span>
<span class="w">        </span><span class="c">!$OMP task shared(sub2) firstprivate(in)</span>
<span class="w">            </span><span class="n">sub2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recursive_fib</span><span class="p">(</span><span class="n">in</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">        </span><span class="c">!$OMP end task</span>
<span class="w">        </span><span class="c">!$OMP taskwait</span>
<span class="w">        </span><span class="n">fibnum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sub1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sub2</span>
<span class="w">    </span><span class="k">else</span>
<span class="k">        </span><span class="n">fibnum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span>
<span class="w">    </span><span class="k">endif</span>
<span class="k">end function </span><span class="n">recursive_fib</span>
</pre></div>
</div>
<p><em>Solution</em></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">taskwait</span></code> waits for the 2 tasks above</p></li>
<li><p>Recursion takes care of grandchildren automatically</p></li>
</ul>
<p><em>Calling the Parallel Fibonacci</em></p>
<p>Original Serial Code</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">program </span><span class="n">fibonacci</span>
<span class="w">    </span><span class="c">!$ use omp_lib</span>
<span class="w">    </span><span class="kt">integer</span><span class="p">,</span><span class="w"> </span><span class="k">parameter</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">selected_int_kind</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="w">    </span><span class="kt">integer</span><span class="p">(</span><span class="n">lint</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">fibres</span>
<span class="w">    </span><span class="kt">integer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">input</span>

<span class="w">    </span><span class="k">read</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">input</span>
<span class="w">    </span><span class="n">fibres</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recursive_fib</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
<span class="w">    </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Fibonacci number&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot; is:&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fibres</span>
<span class="k">end program </span><span class="n">fibonacci</span>
</pre></div>
</div>
<p><em>Attempt: Starting Parallel Region</em></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">program </span><span class="n">fibonacci</span>
<span class="w">    </span><span class="c">!$ use omp_lib</span>
<span class="w">    </span><span class="kt">integer</span><span class="p">,</span><span class="w"> </span><span class="k">parameter</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">selected_int_kind</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="w">    </span><span class="kt">integer</span><span class="p">(</span><span class="n">lint</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">fibres</span>
<span class="w">    </span><span class="kt">integer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">input</span>

<span class="w">    </span><span class="k">read</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">input</span>
<span class="w">    </span><span class="c">!$OMP parallel shared(input, fibres) default(none)</span>
<span class="w">        </span><span class="n">fibres</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recursive_fib</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
<span class="w">    </span><span class="c">!$OMP end parallel</span>
<span class="w">    </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Fibonacci number&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot; is:&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fibres</span>
<span class="k">end program </span><span class="n">fibonacci</span>
</pre></div>
</div>
<div class="admonition danger">
<p class="admonition-title">Danger</p>
<p><strong>Problem:</strong> Each thread starts Fibonacci calculation! Multiple redundant computations.</p>
</div>
<p><em>Solution: Using single Construct</em></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">program </span><span class="n">fibonacci</span>
<span class="w">    </span><span class="c">!$ use omp_lib</span>
<span class="w">    </span><span class="kt">integer</span><span class="p">,</span><span class="w"> </span><span class="k">parameter</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">selected_int_kind</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="w">    </span><span class="kt">integer</span><span class="p">(</span><span class="n">lint</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">fibres</span>
<span class="w">    </span><span class="kt">integer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">input</span>

<span class="w">    </span><span class="k">read</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">input</span>
<span class="w">    </span><span class="c">!$OMP parallel shared(input, fibres) default(none)</span>
<span class="w">        </span><span class="c">!$OMP single</span>
<span class="w">            </span><span class="n">fibres</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recursive_fib</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
<span class="w">        </span><span class="c">!$OMP end single</span>
<span class="w">    </span><span class="c">!$OMP end parallel</span>
<span class="w">    </span><span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Fibonacci number&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot; is:&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fibres</span>
<span class="k">end program </span><span class="n">fibonacci</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">single</span></code> ensures only one thread starts the recursion, but all threads can help execute tasks.</p>
</div>
<p><em>Performance: Fibonacci Number 40</em></p>
<p>Benchmark Setup</p>
<p><strong>Hardware:</strong> Intel E5-2650 v3
<strong>Test:</strong> Computing Fibonacci(40)
<strong>Compilers:</strong> gfortran 6.3, ifort 17.1</p>
<p>Results Summary</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/perf-fibo.png"><img alt="../_images/perf-fibo.png" src="../_images/perf-fibo.png" style="width: 495.0px; height: 351.0px;" /></a>
</figure>
<hr class="docutils" />
<p><em>Key Observations</em></p>
<p>Both compilers show similar patterns:</p>
<ul class="simple">
<li><p><strong>Naive implementation</strong> (2 tasks per iteration): Poor performance</p></li>
<li><p><strong>Using if clause</strong> (no tasks for low values): Helps significantly</p></li>
<li><p><strong>1 task per iteration</strong>: Helps even more</p></li>
<li><p><strong>Problem:</strong> Too little work per task</p></li>
<li><p><strong>Solution:</strong> Limit the number of tasks created</p></li>
</ul>
<p><em>Discussion: Fibonacci Performance</em></p>
<p>Key Findings</p>
<p><strong>Task Overhead:</strong></p>
<ul class="simple">
<li><p>Creating tasks has significant overhead</p></li>
<li><p>Need sufficient work per task to justify overhead</p></li>
</ul>
<p><strong>Optimization Strategies:</strong></p>
<ol class="arabic simple">
<li><p><strong>if clause:</strong> Prevents task creation for small problem sizes</p></li>
<li><p><strong>Limit task creation:</strong> Only create tasks at higher recursion levels</p></li>
<li><p><strong>Balance:</strong> Between parallelism and overhead</p></li>
</ol>
<p>Hardware Details</p>
<p><strong>Test System:</strong></p>
<ul class="simple">
<li><p>2 sockets per server</p></li>
<li><p>Intel E5-2650 v3</p></li>
<li><p>10 cores per processor</p></li>
</ul>
<p><strong>Compilers:</strong></p>
<ul class="simple">
<li><p><strong>gfortran:</strong> Version 6.3 with thread binding</p></li>
<li><p><strong>Intel ifort:</strong> Version 17.1 with thread binding</p></li>
</ul>
<p><em>Case Study 2: Self-Refining Recursive Integrator</em></p>
<p>Mesh Refinement Concept</p>
<p>Codes employing irregular grids benefit from dynamic grid refinement/coarsening:</p>
<p><strong>Example: Fluid dynamics</strong></p>
<ul class="simple">
<li><p>Refine grid where eddy develops</p></li>
<li><p>Coarsen when eddy vanishes</p></li>
</ul>
<p><em>Case Study Application</em></p>
<p>Self-refining integrator for 1D function.</p>
</section>
<section id="basic-algorithm">
<h2>Basic Algorithm<a class="headerlink" href="#basic-algorithm" title="Permalink to this heading"></a></h2>
<p>Integration with Adaptive Refinement</p>
<ol class="arabic simple">
<li><p><strong>Evaluate function</strong> at 5 regularly spaced points in interval</p></li>
<li><p><strong>Estimate integral</strong> using two methods:</p>
<ul class="simple">
<li><p>Polygon using all 5 points (accurate)</p></li>
<li><p>Polygon using only 3 points (first, center, last) (coarse)</p></li>
</ul>
</li>
<li><p><strong>Check difference</strong> between the two integrals:</p>
<ul class="simple">
<li><p>Compare to threshold * interval length</p></li>
</ul>
</li>
<li><p><strong>Decision:</strong></p>
<ul class="simple">
<li><p><strong>If accurate:</strong> Add contribution to accumulator</p></li>
<li><p><strong>If not accurate:</strong></p>
<ul>
<li><p>Split interval into two pieces</p></li>
<li><p>Run integrator on both pieces (recursion)</p></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><em>Implementation: Parallel Region</em></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="n">accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0D0</span>

<span class="c">!$OMP parallel default(none) &amp;</span>
<span class="c">!$OMP shared(accumulator) &amp;</span>
<span class="c">!$OMP shared(startv, stopv, unit_err, gen_num)</span>
<span class="w">    </span><span class="c">!$OMP single</span>
<span class="w">        </span><span class="k">call </span><span class="n">rec_eval_shared_update</span><span class="p">(</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">            </span><span class="n">startv</span><span class="p">,</span><span class="w"> </span><span class="n">stopv</span><span class="p">,</span><span class="w"> </span><span class="n">unit_err</span><span class="p">,</span><span class="w"> </span><span class="n">gen_num</span><span class="p">)</span>
<span class="w">    </span><span class="c">!$OMP end single</span>
<span class="c">!$OMP end parallel</span>
</pre></div>
</div>
<p><em>Key Design Decisions</em></p>
<p><strong>Shared variable accumulator:</strong></p>
<ul class="simple">
<li><p>Declared as module variable</p></li>
<li><p>Used to accumulate results</p></li>
</ul>
<p><strong>single construct:</strong></p>
<ul class="simple">
<li><p>Starts the recursive integrator once</p></li>
<li><p>Implied barrier ensures all tasks are finished</p></li>
</ul>
<p><strong>Recursive subroutine:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rec_eval_shared_update</span></code></p></li>
</ul>
<p><em>Implementation: Task Startup</em></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!$OMP task shared(accumulator) firstprivate(my_start, my_stop) &amp;</span>
<span class="c">!$OMP default(none) firstprivate(my_gen, u_err) &amp;</span>
<span class="c">!$OMP if(task_start)</span>
<span class="w">    </span><span class="k">call </span><span class="n">rec_eval_shared_update</span><span class="p">(</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">        </span><span class="n">my_start</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5_dpr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">my_start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">my_stop</span><span class="p">),</span><span class="w"> </span><span class="n">u_err</span><span class="p">,</span><span class="w"> </span><span class="n">my_gen</span><span class="p">)</span>
<span class="c">!$OMP end task</span>

<span class="c">!$OMP task shared(accumulator) firstprivate(my_start, my_stop) &amp;</span>
<span class="c">!$OMP default(none) firstprivate(my_gen, u_err) &amp;</span>
<span class="c">!$OMP if(task_start)</span>
<span class="w">    </span><span class="k">call </span><span class="n">rec_eval_shared_update</span><span class="p">(</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">        </span><span class="mf">0.5_dpr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">my_start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">my_stop</span><span class="p">),</span><span class="w"> </span><span class="n">my_stop</span><span class="p">,</span><span class="w"> </span><span class="n">u_err</span><span class="p">,</span><span class="w"> </span><span class="n">my_gen</span><span class="p">)</span>
<span class="c">!$OMP end task</span>
</pre></div>
</div>
<p>Recursion Strategy</p>
<ul class="simple">
<li><p>Split interval in half</p></li>
<li><p>Create two tasks for sub-intervals</p></li>
<li><p>Each task may recursively subdivide further</p></li>
</ul>
<p><em>Implementation: Result Accumulation</em></p>
<p>Three Approaches</p>
<p><strong>1. Shared variable with atomic update:</strong></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!$omp atomic update</span>
<span class="n">accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">accumulator</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">contribution</span>
</pre></div>
</div>
<p><strong>2. Threadprivate variables:</strong></p>
<ul class="simple">
<li><p>Thread executing task adds to its threadprivate copy</p></li>
<li><p>After barrier (implied in <code class="docutils literal notranslate"><span class="pre">end</span> <span class="pre">single</span></code>): atomic update of threadprivate data into shared variable</p></li>
</ul>
<p><strong>Remarks:</strong></p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Be careful with threadprivate and task scheduling points!</p>
<ul class="simple">
<li><p>Value can be changed after scheduling point</p></li>
<li><p>threadprivate isn’t private to the task</p></li>
</ul>
</div>
<p><strong>OpenMP 5.0:</strong></p>
<p>OpenMP 5.0 has reduction constructs for tasks.</p>
<p><em>Test Function</em></p>
<p>Mathematical Function</p>
<div class="math notranslate nohighlight">
\[f(x) = \sin^2(10000x) \cdot \sin^4(x)\]</div>
<p>Properties</p>
<ul class="simple">
<li><p>Highly oscillatory (due to sin(10000x) term)</p></li>
<li><p>Requires adaptive refinement</p></li>
<li><p>Samples more densely where function varies rapidly</p></li>
</ul>
<p>Sampling Pattern</p>
<p>The integrator samples most densely where the function oscillates most rapidly, demonstrating the effectiveness of adaptive refinement.</p>
<p><em>Performance Results: Integrator</em></p>
<p>Configuration</p>
<ul class="simple">
<li><p>Task started every 5th generation</p></li>
<li><p>Two accumulation strategies tested</p></li>
</ul>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/perf-res.png"><img alt="../_images/perf-res.png" src="../_images/perf-res.png" style="width: 351.0px; height: 283.5px;" /></a>
</figure>
<hr class="docutils" />
<p><em>Key Findings</em></p>
<p><strong>Atomic updates:</strong></p>
<ul class="simple">
<li><p>Poor results (millions of atomic operations)</p></li>
</ul>
<p><strong>Threadprivate accumulation:</strong></p>
<ul class="simple">
<li><p>Satisfactory results</p></li>
<li><p>Efficient utilization of up to 128 cores</p></li>
</ul>
<p><em>Compiler Comparison: Integrator</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>GCC shows inferior scalability beyond 20 cores compared to Intel compiler.</p>
</div>
</section>
<section id="task-dependencies-openmp-4-0">
<h2>Task Dependencies (OpenMP 4.0)<a class="headerlink" href="#task-dependencies-openmp-4-0" title="Permalink to this heading"></a></h2>
<p>Declare explicit dependencies between tasks to control execution order.</p>
<p>Syntax</p>
<p><strong>Fortran:</strong></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!$omp task depend(type : list)</span>
</pre></div>
</div>
<p><strong>C:</strong></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma omp task depend(type : list)</span>
</pre></div>
</div>
<p><em>Dependency Types</em></p>
<p><strong>in:</strong></p>
<ul class="simple">
<li><p>Task depends on all previous siblings with <code class="docutils literal notranslate"><span class="pre">out</span></code> or <code class="docutils literal notranslate"><span class="pre">inout</span></code> dependency on one or more list items</p></li>
</ul>
<p><strong>out, inout:</strong></p>
<ul class="simple">
<li><p>Task depends on all previous siblings with <code class="docutils literal notranslate"><span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">out</span></code>, or <code class="docutils literal notranslate"><span class="pre">inout</span></code> dependency on one or more list items</p></li>
</ul>
<p><em>List Format</em></p>
<p>The list contains variables, which may include array sections.</p>
<p><em>Example: Task Dependencies</em></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma omp task depend(out: a)</span>
<span class="n">task_function_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>

<span class="cp">#pragma omp task depend(in: a)</span>
<span class="n">task_function_2</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>

<span class="cp">#pragma omp task depend(in: a)</span>
<span class="n">task_function_3</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
<p><em>Execution Order</em></p>
<ol class="arabic simple">
<li><p><strong>Wait</strong> for <code class="docutils literal notranslate"><span class="pre">task_function_1</span></code> to finish (it writes <code class="docutils literal notranslate"><span class="pre">a</span></code>)</p></li>
<li><p><strong>Then execute</strong> <code class="docutils literal notranslate"><span class="pre">task_function_2</span></code> and <code class="docutils literal notranslate"><span class="pre">task_function_3</span></code> in any order on any thread (both read <code class="docutils literal notranslate"><span class="pre">a</span></code>)</p></li>
</ol>
<p><em>Benefits</em></p>
<ul class="simple">
<li><p>Explicit control over task ordering</p></li>
<li><p>Runtime can optimize scheduling within dependency constraints</p></li>
<li><p>More flexible than barriers</p></li>
</ul>
</section>
<section id="taskloop-construct-openmp-4-5">
<h2>taskloop Construct (OpenMP 4.5)<a class="headerlink" href="#taskloop-construct-openmp-4-5" title="Permalink to this heading"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">taskloop</span></code> construct distributes loop iterations onto tasks.</p>
<p><em>Similarity</em></p>
<p>Similar to the loop construct (<code class="docutils literal notranslate"><span class="pre">omp</span> <span class="pre">for</span></code>/<code class="docutils literal notranslate"><span class="pre">omp</span> <span class="pre">do</span></code>), but creates tasks instead of directly distributing iterations.</p>
<p><em>Default Behavior</em></p>
<p>By default, <code class="docutils literal notranslate"><span class="pre">taskloop</span></code> implies a <code class="docutils literal notranslate"><span class="pre">taskgroup</span></code>.</p>
<p><strong>taskloop: Basic Syntax</strong></p>
<p><em>Fortran</em></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!$OMP taskloop default(none) shared(…) private(…)</span>
<span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">N</span>
<span class="w">    </span><span class="p">...</span>
<span class="k">enddo</span>
</pre></div>
</div>
<p><em>C</em></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma omp taskloop default(none) shared(…) private(…)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="clauses-for-taskloop">
<h2>Clauses for taskloop<a class="headerlink" href="#clauses-for-taskloop" title="Permalink to this heading"></a></h2>
<p><em>Standard Clauses</em></p>
<p>Clauses introduced previously that work with <code class="docutils literal notranslate"><span class="pre">taskloop</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">if(scalar-expr)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shared</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">private</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">firstprivate</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lastprivate</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">default</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">collapse</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">final(scalar-expr)</span></code></p></li>
</ul>
<p><em>Important Differences</em></p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<ul class="simple">
<li><p><strong>No</strong> <code class="docutils literal notranslate"><span class="pre">reduction</span></code> clause for taskloop</p></li>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">nogroup</span></code> clause to remove the implied <code class="docutils literal notranslate"><span class="pre">taskgroup</span></code></p></li>
</ul>
</div>
<p><em>Additional Construct</em></p>
<p>There is also a <code class="docutils literal notranslate"><span class="pre">taskloop</span> <span class="pre">simd</span></code> construct for vectorization.</p>
</section>
<section id="controlling-number-of-tasks-created">
<h2>Controlling Number of Tasks Created<a class="headerlink" href="#controlling-number-of-tasks-created" title="Permalink to this heading"></a></h2>
<p>Control the granularity of task creation to balance parallelism and overhead.</p>
<p><em>Clauses</em></p>
<p>Use <code class="docutils literal notranslate"><span class="pre">grainsize</span></code> <strong>or</strong> <code class="docutils literal notranslate"><span class="pre">num_tasks</span></code> (only one allowed):</p>
<p><em>grainsize Clause</em></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!$omp taskloop grainsize(100)</span>
</pre></div>
</div>
<p>Controls number of loop iterations per task:</p>
<ul class="simple">
<li><p>Each task gets between <code class="docutils literal notranslate"><span class="pre">grainsize</span></code> and <code class="docutils literal notranslate"><span class="pre">2*grainsize</span></code> iterations</p></li>
</ul>
<p><em>num_tasks Clause</em></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!$omp taskloop num_tasks(10)</span>
</pre></div>
</div>
<p>Specifies the number of tasks to create.</p>
<p><em>Additional Restrictions</em></p>
<p>Final number of tasks may be affected by iteration count and other factors.</p>
<div class="admonition-exercise exercise important admonition" id="exercise-0">
<p class="admonition-title">Exercise</p>
<p>Use two tasks where each prints out <em>Hello</em> and <em>World</em> strings. Use 4 threads.</p>
</div>
<div class="admonition-solution solution important dropdown admonition" id="solution-0">
<p class="admonition-title">Solution</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// On cluster Kebnekaise</span>
<span class="linenos"> 2</span><span class="c1">// ml foss</span>
<span class="linenos"> 3</span><span class="c1">// export OMP_NUM_THREADS=1</span>
<span class="linenos"> 4</span><span class="c1">// gcc -O3 -march=native -fopenmp -o test.x 12a-task-openmp.c -lm</span>
<span class="linenos"> 5</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="linenos"> 6</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span>
<span class="linenos"> 7</span>
<span class="linenos"> 8</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="w">    </span><span class="cp">#pragma omp parallel num_threads(4)</span>
<span class="linenos">11</span><span class="w">    </span><span class="p">{</span>
<span class="linenos">12</span>
<span class="linenos">13</span><span class="w">        </span><span class="cp">#pragma omp task</span>
<span class="linenos">14</span><span class="w">        </span><span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);}</span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="w">        </span><span class="cp">#pragma omp task</span>
<span class="linenos">17</span><span class="w">        </span><span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;World</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);}</span>
<span class="linenos">18</span>
<span class="linenos">19</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">20</span>
<span class="linenos">21</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">22</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="admonition-exercise exercise important admonition" id="exercise-1">
<p class="admonition-title">Exercise</p>
<p>Inspect and run the following code to see the behavior of shared, private, and first private variables in the context of tasks.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// On cluster Kebnekaise</span>
<span class="linenos"> 2</span><span class="c1">// ml foss</span>
<span class="linenos"> 3</span><span class="c1">// export OMP_NUM_THREADS=1</span>
<span class="linenos"> 4</span><span class="c1">// gcc -O3 -march=native -fopenmp -o test.x 13a-sharedprivate-task-openmp.c -lm</span>
<span class="linenos"> 5</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="linenos"> 6</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span>
<span class="linenos"> 7</span>
<span class="linenos"> 8</span><span class="kt">void</span><span class="w"> </span><span class="nf">process_task</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">shared_data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 9</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Task %d: shared_data = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">shared_data</span><span class="p">);</span>
<span class="linenos">10</span><span class="p">}</span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">13</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">shared_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="c1">// variable that is shared across tasks</span>
<span class="linenos">14</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">private_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">200</span><span class="p">;</span><span class="w"> </span><span class="c1">// variable is private to each task</span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="w">    </span><span class="cp">#pragma omp parallel</span>
<span class="linenos">17</span><span class="w">    </span><span class="p">{</span>
<span class="linenos">18</span><span class="w">        </span><span class="cp">#pragma omp single</span>
<span class="linenos">19</span><span class="w">        </span><span class="p">{</span>
<span class="linenos">20</span><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">21</span><span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">firstprivate_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="c1">// firstprivate variable: unique for each task but initialized with i * 10</span>
<span class="linenos">22</span>
<span class="linenos">23</span><span class="w">                </span><span class="cp">#pragma omp task shared(shared_data) private(private_data) firstprivate(firstprivate_data)</span>
<span class="linenos">24</span><span class="w">                </span><span class="p">{</span>
<span class="linenos">25</span><span class="w">                    </span><span class="c1">// here we modify the private_data variable, which is unique to each task</span>
<span class="linenos">26</span><span class="w">                    </span><span class="n">private_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="linenos">27</span><span class="w">                    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Task %d: private_data = %d, firstprivate_data = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">private_data</span><span class="p">,</span><span class="w"> </span><span class="n">firstprivate_data</span><span class="p">);</span>
<span class="linenos">28</span>
<span class="linenos">29</span><span class="w">                    </span><span class="c1">// Calling a function with shared data</span>
<span class="linenos">30</span><span class="w">                    </span><span class="n">process_task</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">shared_data</span><span class="p">);</span>
<span class="linenos">31</span>
<span class="linenos">32</span><span class="w">                    </span><span class="c1">// Use an atomic op. for shared_data  or critical?</span>
<span class="linenos">33</span><span class="w">                    </span><span class="cp">#pragma omp atomic</span>
<span class="linenos">34</span><span class="w">                    </span><span class="n">shared_data</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="linenos">35</span><span class="w">                </span><span class="p">}</span>
<span class="linenos">36</span><span class="w">            </span><span class="p">}</span>
<span class="linenos">37</span><span class="w">        </span><span class="p">}</span>
<span class="linenos">38</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">39</span>
<span class="linenos">40</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Final value of shared_data: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">shared_data</span><span class="p">);</span>
<span class="linenos">41</span>
<span class="linenos">42</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">43</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="admonition-exercise exercise important admonition" id="exercise-2">
<p class="admonition-title">Exercise</p>
<p>Inspect and run the following code to see the behavior of first private variables in the context of tasks.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// On cluster Kebnekaise</span>
<span class="linenos"> 2</span><span class="c1">// ml foss</span>
<span class="linenos"> 3</span><span class="c1">// export OMP_NUM_THREADS=1</span>
<span class="linenos"> 4</span><span class="c1">// gcc -O3 -march=native -fopenmp -o test.x 13b-firstprivate-task-openmp.c -lm</span>
<span class="linenos"> 5</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="linenos"> 6</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span>
<span class="linenos"> 7</span>
<span class="linenos"> 8</span><span class="kt">void</span><span class="w"> </span><span class="nf">task_example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 9</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// a shared variable with an initial value</span>
<span class="linenos">10</span>
<span class="linenos">11</span><span class="w">    </span><span class="cp">#pragma omp parallel</span>
<span class="linenos">12</span><span class="w">    </span><span class="p">{</span>
<span class="linenos">13</span><span class="w">        </span><span class="cp">#pragma omp single</span>
<span class="linenos">14</span><span class="w">        </span><span class="p">{</span>
<span class="linenos">15</span><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">16</span><span class="w">                </span><span class="cp">#pragma omp task private(n) firstprivate(n)</span>
<span class="linenos">17</span><span class="w">                </span><span class="p">{</span>
<span class="linenos">18</span><span class="w">                    </span><span class="c1">// n is private to each task, initialized with its value at task creation</span>
<span class="linenos">19</span><span class="w">                    </span><span class="n">n</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="c1">// Modify n for this task</span>
<span class="linenos">20</span><span class="w">                    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Task %d: n = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="linenos">21</span><span class="w">                </span><span class="p">}</span>
<span class="linenos">22</span><span class="w">            </span><span class="p">}</span>
<span class="linenos">23</span><span class="w">        </span><span class="p">}</span>
<span class="linenos">24</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">25</span><span class="p">}</span>
<span class="linenos">26</span>
<span class="linenos">27</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">28</span><span class="w">    </span><span class="n">task_example</span><span class="p">();</span>
<span class="linenos">29</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">30</span><span class="p">}</span>
</pre></div>
</div>
</div>
</section>
<section id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this heading"></a></h2>
<p><strong>Task Construct:</strong></p>
<ul class="simple">
<li><p>Flexible parallelism for irregular problems</p></li>
<li><p>Tasks can be created dynamically</p></li>
<li><p>Execution by any thread, now or later</p></li>
</ul>
<p><strong>Task Scheduling:</strong></p>
<ul class="simple">
<li><p>Task scheduling points</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">taskwait</span></code>: wait for child tasks</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">taskgroup</span></code>: wait for all descendants</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">taskyield</span></code>: allow suspension</p></li>
</ul>
<p><strong>Task Completion:</strong></p>
<ul class="simple">
<li><p>Multiple mechanisms to control when tasks finish</p></li>
<li><p>Dependencies between tasks (OpenMP 4.0)</p></li>
</ul>
<p><strong>Performance Aspects:</strong></p>
<ul class="simple">
<li><p>Task creation has overhead</p></li>
<li><p>Need decent amount of work per task</p></li>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">final</span></code> clauses to control task generation</p></li>
<li><p>Balance between parallelism and overhead</p></li>
</ul>
<p><strong>Case Studies:</strong></p>
<ul class="simple">
<li><p>Recursive Fibonacci: demonstrated task basics</p></li>
<li><p>Self-refining integrator: demonstrated adaptive algorithms</p></li>
</ul>
<p><strong>Advanced Features:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">taskloop</span></code> (OpenMP 4.5): distribute loops onto tasks</p></li>
<li><p>Task dependencies: explicit ordering</p></li>
<li><p>Various accumulation strategies for results</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../worksharingii/" class="btn btn-neutral float-left" title="More on Worksharing" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../quick-reference/" class="btn btn-neutral float-right" title="Quick Reference" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, The contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>